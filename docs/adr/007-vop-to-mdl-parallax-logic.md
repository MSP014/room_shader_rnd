# Architecture Decision Record: 007 - MDL Parallax Interior Mapping (PIM) Strategy

## Context

The Parallax Interior Mapping logic for Case 01 is handled in Houdini by the locked `kma_roommap` VOP. Since the internal VEX code is inaccessible (a "black box"), and given that a direct code translation would likely carry over unnecessary Houdini-specific legacy operations, we must implement a clean, mathematically pure Parallax Interior Mapping (PIM) algorithm natively in NVIDIA MDL.

This custom implementation must satisfy the following constraints:

1. Accept the exact attributes generated by the `Room Map Frame SOP` (`roomP`, `tangentu`, `tangentv` as Vertex primvars).
2. Project a cross-shaped interior texture correctly onto the proxy geometry.
3. Support layered depth slices with alpha blending.

## Decision

We will build a custom **Parallax Interior Mapping (PIM)** function in MDL.

### 1. Spatial Transformation (World to Local)

Instead of operating in World Space, the shader will construct a **Local Tangent Space** for the room interior using the incoming USD Primvars:

* Local $X$-axis = `tangentu`
* Local $Y$-axis = `tangentv`
* Local $Z$-axis = `roomN` (computed via cross product of U and V, or read from primvar).
* Center of the room = `roomP`

The incoming camera view vector (`state::direction()`) will be transformed into this Local Space to perform intersection tests against a normalized "virtual room box" (e.g., coordinates from -1 to 1).

### 2. Ray-Box Intersection (The Parallax Effect)

We will use an optimized AABB (Axis-Aligned Bounding Box) intersection algorithm inside the fragment shader:

1. Calculate the intersection of the local view ray with the internal walls of the virtual box.
2. Determine which wall (Back, Left, Right, Top, Bottom) the ray hits based on the shortest positive distance.
3. The intersection coordinates (in the range [-1, 1]) will then be mapped to the UV coordinates of that specific wall.

### 3. Texture Mapping (The Cross Layout)

The standard Houdini room map texture is laid out in a cross shape. We will implement a UV remapping function in MDL that translates the local intersection point on the virtual 3D box into the correct 2D UV tile within the cross layout:

* `[1/3, 1/3]` to `[2/3, 2/3]` -> Back Wall
* `[0, 1/3]` to `[1/3, 2/3]` -> Left Wall
* `[2/3, 1/3]` to `[1, 2/3]` -> Right Wall
* `[1/3, 2/3]` to `[2/3, 1]` -> Ceiling
* `[1/3, 0]` to `[2/3, 1/3]` -> Floor

### 4. Slices (Depth Layers)

To support depth layers (like curtains or furniture):

1. We define arbitrary Z-depth planes between the window plane ($Z=1$) and the back wall ($Z=-1$).
2. The ray equation is solved for these Z-planes.
3. If an intersection occurs within the X and Y bounds of the room, we sample the respective slice's texture (located in the corners of the cross layout).
4. Standard alpha blending `mix(room_color, slice_color, slice_alpha)` is applied.

### 5. Instance Variation (UDIM Offset)

In the original Houdini setup, UDIM tile variation is driven by a `Voronoi Noise 3D` node. The `roomP` (or `roomID`) attribute acts as the seed/position for the noise, and the result is remapped via `mtlxrange_rooms` into an integer `offset` for the `kma_roommap` node.
Our MDL shader will mimic this:

1. We expose a `room_offset` integer parameter on the main Material.
2. In the DCC (or via Omniverse OmniGraph/MaterialX graph), the user will generate a pseudo-random integer based on the `roomID` primvar (using a noise or hash function).
3. This integer is passed to our MDL shader, which shifts the UV lookup to the corresponding texture sequence/UDIM tile, guaranteeing that windows with different `roomIDs` get different interiors.

## Consequences

* **Performance**: OptiX will JIT-compile this pure mathematical approach into a highly optimized GPU kernel. Bypassing Houdini's unoptimized VEX logic guarantees better performance at scale (Case 01).
* **Maintenance**: We own the code. If the cross-layout format changes or we need to add 8 slices instead of 4, we modify our own MDL module.
* **Portability**: While optimized for the `Room Map Frame SOP` primvars, the core PIM maths function can easily be decoupled to accept standard UVs and Tangents for non-Houdini users (as per the Hybrid Geometry Strategy in ADR 001).
